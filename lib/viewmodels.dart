import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart' hide Theme;
import 'models.dart';

class MemoViewModel extends ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  // No more in-memory lists or maps! Data comes directly from Firestore via streams.
  // The constructor no longer initializes default data.
  // Helper to get the current user's ID
  String? get currentUserId => _auth.currentUser?.uid;
  // --- Theme Operations ---
  // Exposes a Stream of ThemeModel lists for UI to listen to
  Stream<List<ThemeModel>> get userThemesStream {
    final userId = currentUserId;
    if (userId == null) {
      // Return an empty stream if no user is signed in.
      // The UI should handle this case (e.g., show a login prompt).
      return Stream.value([]);
    }

    return _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .orderBy(
          'createdAt',
          descending: true,
        ) // Assuming you add 'createdAt' to your theme documents
        .snapshots() // This is the magic for real-time updates!
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => ThemeModel.fromFirestore(doc))
              .toList();
        });
  }

  // Function to add a new theme
  Future<void> addTheme(String themeName) async {
    final userId = currentUserId;
    if (userId == null) {
      // In a real app, you might throw an error, navigate to login, or show a message.
      print("Error: User not signed in. Cannot add theme.");
      return;
    }

    final newTheme = ThemeModel(
      id: '',
      name: themeName,
      userId: userId,
    ); // ID will be auto-generated by Firestore
    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .add(newTheme.toFirestore()); // Add the new theme document
  }

  // Function to edit an existing theme's name
  Future<void> editTheme(ThemeModel themeToEdit, String newName) async {
    final userId = currentUserId;
    if (userId == null) {
      print("Error: User not signed in. Cannot edit theme.");
      return;
    }

    // Ensure the theme belongs to the current user (Firestore rules will also enforce this)
    if (themeToEdit.userId != userId) {
      print("Error: Unauthorized attempt to edit theme.");
      return;
    }

    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(themeToEdit.id) // Use the theme's Firestore ID
        .update({'name': newName}); // Update only the 'name' field
  }

  // Function to remove a theme (and its associated cards)
  Future<void> removeTheme(ThemeModel themeToRemove) async {
    final userId = currentUserId;
    if (userId == null) {
      print("Error: User not signed in. Cannot remove theme.");
      return;
    }

    if (themeToRemove.userId != userId) {
      print("Error: Unauthorized attempt to remove theme.");
      return;
    }

    // IMPORTANT: Firestore does NOT automatically delete subcollections.
    // You must manually delete cards before deleting the theme document.
    // For large numbers of cards, consider using a Cloud Function.

    final cardsSnapshot = await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(themeToRemove.id)
        .collection('cards')
        .get();

    for (var doc in cardsSnapshot.docs) {
      await doc.reference.delete(); // Delete each card
    }
    // Finally, delete the theme document itself
    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(themeToRemove.id)
        .delete();
  }

  // --- FullCard Operations ---
  // Exposes a Stream of FullCardModel lists for a specific theme
  Stream<List<FullCardModel>> cardsForThemeStream(String themeId) {
    final userId = currentUserId;
    if (userId == null) {
      return Stream.value([]);
    }
    return _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(themeId)
        .collection('cards')
        .orderBy(
          'createdAt',
          descending: true,
        ) // Assuming you add 'createdAt' to your card documents
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => FullCardModel.fromFirestore(doc))
              .toList();
        });
  }

  // Function to add a new card to a specific theme
  Future<void> addCard(String themeId, String title, String description) async {
    final userId = currentUserId;
    if (userId == null) {
      print("Error: User not signed in. Cannot add card.");
      return;
    }

    final newCard = FullCardModel(
      id: '', // ID will be auto-generated by Firestore
      themeId: themeId,
      title: title,
      description: description,
      userId: userId,
    );

    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(themeId)
        .collection('cards')
        .add(newCard.toFirestore());
  }

  // Function to edit an existing card's title and description
  Future<void> editCard(
    FullCardModel cardToEdit,
    String newTitle,
    String newDescription,
  ) async {
    final userId = currentUserId;
    if (userId == null) {
      print("Error: User not signed in. Cannot edit card.");
      return;
    }

    if (cardToEdit.userId != userId) {
      print("Error: Unauthorized attempt to edit card.");
      return;
    }

    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(cardToEdit.themeId)
        .collection('cards')
        .doc(cardToEdit.id) // Use the card's Firestore ID
        .update({'title': newTitle, 'description': newDescription});
  }

  // Function to remove a specific card
  Future<void> removeCard(FullCardModel cardToRemove) async {
    final userId = currentUserId;
    if (userId == null) {
      print("Error: User not signed in. Cannot remove card.");
      return;
    }

    if (cardToRemove.userId != userId) {
      print("Error: Unauthorized attempt to remove card.");
      return;
    }

    await _firestore
        .collection('users')
        .doc(userId)
        .collection('themes')
        .doc(cardToRemove.themeId)
        .collection('cards')
        .doc(cardToRemove.id) // Use the card's Firestore ID
        .delete();
  }
}
